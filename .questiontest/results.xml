<?xml version="1.0" encoding="utf-8"?><testsuite errors="0" failures="15" name="pytest" skipped="0" tests="15" time="4.034"><testcase classname="test_gateway.tavern.yaml" file="test_gateway.tavern.yaml" line="0" name="gateway_operations" time="0.476"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1d748&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_1&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31130f98&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d198&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1d748&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d198&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_1&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/js...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d080&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_1&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_1&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_1&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_1&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 61\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b1ff28&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31130f98&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1d748&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_1&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31130f98&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d198&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1d748&gt;, _stacktrace = &lt;traceback object at 0x7f3d31b26288&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d31b1f160&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d34c930b8&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_1&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d34c930b8&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b1ff28&gt;, start = 1578473953.3939998

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b1ff28&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31130f98&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d2e8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d30ecc950&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem gateway_operations&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...perations&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem gateway_operations&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...perations&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem gateway_operations&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...perations&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem gateway_operations&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d310b9898&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...perations&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem gateway_operations&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem gateway_operations&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem gateway_operations&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_gateway.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;gateway_operations&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addr....8.8.8&apos;], &apos;name&apos;: &apos;gateway_1&apos;, &apos;id&apos;: &lt;tavern.util.loader.IntToken object at 0x7f3d30e4ff28&gt;}}, &apos;name&apos;: &apos;get_gateway&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d34c930b8&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gatewa...&apos;gateway_id&apos;: &apos;id&apos;}}, &apos;body&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_1&apos;}}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd....1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_1&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d31b1f160&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d31b1d2e8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_gateway.tavern.yaml" file="test_gateway.tavern.yaml" line="0" name="create_gateway_empty_name" time="0.008"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2db90eb8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;52&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db90dd8&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dbab7b8&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2db90eb8&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dbab7b8&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Con...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dbab860&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;52&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;52&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 52\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2db90b70&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db90dd8&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2db90eb8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;52&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db90dd8&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dbab7b8&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2db90eb8&gt;, _stacktrace = &lt;traceback object at 0x7f3d2da73348&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2db90cc0&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2db90550&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2db90550&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2db90b70&gt;, start = 1578473953.6539526

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2db90b70&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db90dd8&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2dbab828&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2dc7d7b8&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_empty_name&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...mpty_name&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_empty_name&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...mpty_name&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_empty_name&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...mpty_name&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_empty_name&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d30e1fe80&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...mpty_name&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_empty_name&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem create_gateway_empty_name&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem create_gateway_empty_name&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_gateway.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;create_gateway_empty_name&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;...: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_gateway&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2db90550&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd...s&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2db90cc0&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d2dbab828&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_gateway.tavern.yaml" file="test_gateway.tavern.yaml" line="0" name="create_gateway_no_ips" time="0.007"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2db5aba8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [], &quot;name&quot;: &quot;gateway_2&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;41&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db5aac8&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db5ae48&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2db5aba8&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db5ae48&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [], &quot;name&quot;: &quot;gateway_2&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db5aeb8&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;, body = b&apos;{&quot;ip_addresses&quot;: [], &quot;name&quot;: &quot;gateway_2&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;41&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;, body = b&apos;{&quot;ip_addresses&quot;: [], &quot;name&quot;: &quot;gateway_2&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;41&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [], &quot;name&quot;: &quot;gateway_2&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [], &quot;name&quot;: &quot;gateway_2&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 41\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2db5a898&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db5aac8&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2db5aba8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [], &quot;name&quot;: &quot;gateway_2&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;41&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db5aac8&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db5ae48&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2db5aba8&gt;, _stacktrace = &lt;traceback object at 0x7f3d2da7c708&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2db5a978&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2db57860&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [], &apos;name&apos;: &apos;gateway_2&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2db57860&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2db5a898&gt;, start = 1578473953.887474

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2db5a898&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2db5aac8&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2db5ae80&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2dc7da60&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_no_ips&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ay_no_ips&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_no_ips&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ay_no_ips&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_no_ips&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ay_no_ips&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_no_ips&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d30e718d0&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ay_no_ips&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_no_ips&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem create_gateway_no_ips&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem create_gateway_no_ips&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_gateway.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;create_gateway_no_ips&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [], &apos;name&apos;: &apos;gateway_2&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_gateway&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2db57860&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [], &apos;name&apos;: &apos;gateway_2&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd...ip_addresses&apos;: [], &apos;name&apos;: &apos;gateway_2&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2db5a978&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d2db5ae80&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_gateway.tavern.yaml" file="test_gateway.tavern.yaml" line="0" name="create_gateway_same_name" time="0.007"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b3a908&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_3&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b3aba8&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b3ada0&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b3a908&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b3ada0&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_3&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/js...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b3ac50&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_3&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_3&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_3&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_3&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 61\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b3aa20&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b3aba8&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b3a908&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_3&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b3aba8&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b3ada0&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b3a908&gt;, _stacktrace = &lt;traceback object at 0x7f3d2d93e8c8&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d31b3a710&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d31b33908&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_3&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d31b33908&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b3aa20&gt;, start = 1578473954.1059654

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b3aa20&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b3aba8&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b3ad68&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d31b09bf8&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_same_name&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...same_name&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_same_name&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...same_name&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_same_name&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...same_name&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_same_name&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d2d93a4e0&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...same_name&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_same_name&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem create_gateway_same_name&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem create_gateway_same_name&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_gateway.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;create_gateway_same_name&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;i...8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_3&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_gateway_again&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d31b33908&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_3&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 201}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd....1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_3&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d31b3a710&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d31b3ad68&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_gateway.tavern.yaml" file="test_gateway.tavern.yaml" line="0" name="create_gateway_bad_ips" time="0.007"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2da2c4e0&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;500.500.500.500&quot;], &quot;name&quot;: &quot;gateway_4&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;58&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da2c518&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da2c940&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2da2c4e0&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da2c940&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;500.500.500.500&quot;], &quot;name&quot;: &quot;gateway_4&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/json&apos;...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da2cb00&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;500.500.500.500&quot;], &quot;name&quot;: &quot;gateway_4&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;58&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;500.500.500.500&quot;], &quot;name&quot;: &quot;gateway_4&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;58&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;500.500.500.500&quot;], &quot;name&quot;: &quot;gateway_4&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;500.500.500.500&quot;], &quot;name&quot;: &quot;gateway_4&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 58\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2da2c2e8&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da2c518&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2da2c4e0&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;500.500.500.500&quot;], &quot;name&quot;: &quot;gateway_4&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;58&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da2c518&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da2c940&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2da2c4e0&gt;, _stacktrace = &lt;traceback object at 0x7f3d2db63088&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2da2c3c8&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2da2c0f0&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;500.500.500.500&apos;], &apos;name&apos;: &apos;gateway_4&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2da2c0f0&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2da2c2e8&gt;, start = 1578473954.3394482

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2da2c2e8&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da2c518&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2da2ca20&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2d9ec8c8&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_bad_ips&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...y_bad_ips&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_bad_ips&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...y_bad_ips&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_bad_ips&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...y_bad_ips&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_bad_ips&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d30e25b70&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...y_bad_ips&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_gateway_bad_ips&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem create_gateway_bad_ips&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem create_gateway_bad_ips&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_gateway.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;create_gateway_bad_ips&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_...0.500.500.500&apos;], &apos;name&apos;: &apos;gateway_4&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_gateway&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2da2c0f0&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;500.500.500.500&apos;], &apos;name&apos;: &apos;gateway_4&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd...500.500.500.500&apos;], &apos;name&apos;: &apos;gateway_4&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2da2c3c8&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d2da2ca20&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_gateway.tavern.yaml" file="test_gateway.tavern.yaml" line="0" name="get_gateway_not_exists" time="0.008"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d96eb38&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_16&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d96e860&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d96ec88&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d96eb38&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d96ec88&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_16&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/j...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d96eeb8&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_16&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_16&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_16&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_16&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 62\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d96e668&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d96e860&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d96eb38&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_16&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d96e860&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d96ec88&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d96eb38&gt;, _stacktrace = &lt;traceback object at 0x7f3d2dc00448&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2d96e6d8&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2d96e160&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_16&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2d96e160&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d96e668&gt;, start = 1578473954.5607982

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d96e668&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d96e860&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d96ea58&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2db8d400&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem get_gateway_not_exists&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ot_exists&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem get_gateway_not_exists&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ot_exists&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem get_gateway_not_exists&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ot_exists&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem get_gateway_not_exists&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d2db90a20&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ot_exists&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem get_gateway_not_exists&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem get_gateway_not_exists&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem get_gateway_not_exists&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_gateway.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;get_gateway_not_exists&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_...ttp://localhost:8000/gateway/1948102948/&apos;, &apos;method&apos;: &apos;GET&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 404}, &apos;name&apos;: &apos;get_gateway&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2d96e160&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_16&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 201}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd...1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_16&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2d96e6d8&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d2d96ea58&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_route.tavern.yaml" file="test_route.tavern.yaml" line="0" name="route_operations" time="0.008"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2df17400&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_5&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2df171d0&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2df179b0&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2df17400&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2df179b0&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_5&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/js...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2df175c0&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_5&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_5&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_5&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_5&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 61\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2df1ef28&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2df171d0&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2df17400&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_5&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2df171d0&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2df179b0&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2df17400&gt;, _stacktrace = &lt;traceback object at 0x7f3d2d955748&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2df17160&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2df1eda0&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_5&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2df1eda0&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2df1ef28&gt;, start = 1578473954.795804

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2df1ef28&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2df171d0&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2df17898&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d30e78e18&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem route_operations&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...perations&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem route_operations&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...perations&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem route_operations&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...perations&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem route_operations&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d30e14a20&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...perations&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem route_operations&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem route_operations&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem route_operations&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_route.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;route_operations&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addres... &apos;gateway_5&apos;}, &apos;id&apos;: &lt;tavern.util.loader.IntToken object at 0x7f3d30e15ef0&gt;, &apos;prefix&apos;: &apos;9190&apos;}}, &apos;name&apos;: &apos;get_route&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2df1eda0&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gatewa... &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 201, &apos;save&apos;: {&apos;body&apos;: {&apos;gateway_id&apos;: &apos;id&apos;}}}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd....1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_5&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2df17160&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d2df17898&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_route.tavern.yaml" file="test_route.tavern.yaml" line="0" name="create_route_empty_prefix" time="0.008"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b3a198&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_6&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabef28&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabea20&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b3a198&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabea20&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_6&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/js...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabe1d0&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_6&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_6&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_6&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_6&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 61\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b3a780&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabef28&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b3a198&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_6&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabef28&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabea20&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b3a198&gt;, _stacktrace = &lt;traceback object at 0x7f3d31b168c8&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d31b3a898&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d31b3aba8&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_6&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d31b3aba8&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b3a780&gt;, start = 1578473955.0426147

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b3a780&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabef28&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabecf8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2dbfebf8&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem create_route_empty_prefix&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ty_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_route_empty_prefix&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ty_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_route_empty_prefix&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ty_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_route_empty_prefix&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d30e153c8&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ty_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_route_empty_prefix&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem create_route_empty_prefix&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem create_route_empty_prefix&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_route.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;create_route_empty_prefix&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;...bject at 0x7f3d30e13b38&gt;, &apos;prefix&apos;: &apos;&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_route&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d31b3aba8&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gatewa... &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 201, &apos;save&apos;: {&apos;body&apos;: {&apos;gateway_id&apos;: &apos;id&apos;}}}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd....1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_6&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d31b3a898&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d2dabecf8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_route.tavern.yaml" file="test_route.tavern.yaml" line="0" name="create_route_bad_prefix" time="0.008"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d920160&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_7&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d920588&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d94dc88&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d920160&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d94dc88&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_7&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/js...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d94d6d8&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_7&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_7&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_7&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_7&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 61\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d920e10&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d920588&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d920160&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_7&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d920588&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d94dc88&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d920160&gt;, _stacktrace = &lt;traceback object at 0x7f3d2d858308&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2d9200f0&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2d920710&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_7&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2d920710&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d920e10&gt;, start = 1578473955.2692347

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d920e10&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d920588&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d94d5f8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2dbfeea0&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem create_route_bad_prefix&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ad_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_route_bad_prefix&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ad_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_route_bad_prefix&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ad_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_route_bad_prefix&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d2d84fc18&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ad_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_route_bad_prefix&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem create_route_bad_prefix&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem create_route_bad_prefix&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_route.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;create_route_bad_prefix&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip...ct at 0x7f3d30e157f0&gt;, &apos;prefix&apos;: &apos;abc&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_route&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2d920710&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gatewa... &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 201, &apos;save&apos;: {&apos;body&apos;: {&apos;gateway_id&apos;: &apos;id&apos;}}}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd....1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_7&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2d9200f0&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d2d94d5f8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_route.tavern.yaml" file="test_route.tavern.yaml" line="0" name="create_route_same_prefix" time="0.008"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1d390&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_8&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d34c86c18&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b505f8&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1d390&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b505f8&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_8&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/js...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b50390&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_8&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_8&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_8&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_8&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 61\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31bc5518&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d34c86c18&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1d390&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_8&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d34c86c18&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b505f8&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1d390&gt;, _stacktrace = &lt;traceback object at 0x7f3d2dbdac08&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d30e5d550&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2da720b8&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_8&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2da720b8&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31bc5518&gt;, start = 1578473955.5232804

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31bc5518&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d34c86c18&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b50470&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2dbeb2f0&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem create_route_same_prefix&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...me_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_route_same_prefix&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...me_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_route_same_prefix&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...me_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_route_same_prefix&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d310b99b0&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...me_prefix&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_route_same_prefix&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem create_route_same_prefix&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem create_route_same_prefix&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_route.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;create_route_same_prefix&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;i...x7f3d30e1bb70&gt;, &apos;prefix&apos;: &apos;9191&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_route_again&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2da720b8&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gatewa... &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 201, &apos;save&apos;: {&apos;body&apos;: {&apos;gateway_id&apos;: &apos;id&apos;}}}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd....1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_8&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d30e5d550&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d31b50470&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_route.tavern.yaml" file="test_route.tavern.yaml" line="0" name="create_route_empty_gateway" time="0.007"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b42c88&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_9&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b426a0&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b42908&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b42c88&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b42908&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_9&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/js...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b42b38&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_9&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_9&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_9&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_9&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 61\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b42588&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b426a0&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b42c88&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_9&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;61&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b426a0&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b42908&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b42c88&gt;, _stacktrace = &lt;traceback object at 0x7f3d2db0a248&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d31b42080&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d30e21b00&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_9&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d30e21b00&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b42588&gt;, start = 1578473955.7438974

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d31b42588&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b426a0&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b42da0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2dbe6620&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem create_route_empty_gateway&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...y_gateway&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_route_empty_gateway&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...y_gateway&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_route_empty_gateway&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...y_gateway&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_route_empty_gateway&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d2dbbc080&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...y_gateway&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_route_empty_gateway&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem create_route_empty_gateway&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem create_route_empty_gateway&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_route.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;create_route_empty_gateway&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {...000/route/&apos;, &apos;json&apos;: {&apos;prefix&apos;: &apos;9192&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_route&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d30e21b00&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gatewa... &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 201, &apos;save&apos;: {&apos;body&apos;: {&apos;gateway_id&apos;: &apos;id&apos;}}}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd....1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_9&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d31b42080&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d31b42da0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_route.tavern.yaml" file="test_route.tavern.yaml" line="0" name="create_route_unknown_gateway" time="0.008"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2da0c828&gt;, method = &apos;POST&apos;, url = &apos;/route/&apos;
body = b&apos;{&quot;gateway_id&quot;: 912348104, &quot;prefix&quot;: &quot;9193&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;43&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da0cf60&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d886320&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2da0c828&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;, method = &apos;POST&apos;
url = &apos;/route/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d886320&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;gateway_id&quot;: 912348104, &quot;prefix&quot;: &quot;9193&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Leng...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d886240&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;, method = &apos;POST&apos;, url = &apos;/route/&apos;, body = b&apos;{&quot;gateway_id&quot;: 912348104, &quot;prefix&quot;: &quot;9193&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;43&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;, method = &apos;POST&apos;, url = &apos;/route/&apos;, body = b&apos;{&quot;gateway_id&quot;: 912348104, &quot;prefix&quot;: &quot;9193&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;43&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;, message_body = b&apos;{&quot;gateway_id&quot;: 912348104, &quot;prefix&quot;: &quot;9193&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;, message_body = b&apos;{&quot;gateway_id&quot;: 912348104, &quot;prefix&quot;: &quot;9193&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;
data = b&apos;POST /route/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 43\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2da0c0f0&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da0cf60&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2da0c828&gt;, method = &apos;POST&apos;, url = &apos;/route/&apos;
body = b&apos;{&quot;gateway_id&quot;: 912348104, &quot;prefix&quot;: &quot;9193&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;43&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da0cf60&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d886320&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/route/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2da0c828&gt;, _stacktrace = &lt;traceback object at 0x7f3d2d6a8788&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /route/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2da0c278&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2d8866a0&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/route/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;gateway_id&apos;: 912348104, &apos;prefix&apos;: &apos;9193&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2d8866a0&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2da0c0f0&gt;, start = 1578473955.9871254

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2da0c0f0&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2da0cf60&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /route/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d886358&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2db96268&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem create_route_unknown_gateway&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...n_gateway&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_route_unknown_gateway&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...n_gateway&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem create_route_unknown_gateway&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...n_gateway&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_route_unknown_gateway&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d2d886e80&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...n_gateway&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem create_route_unknown_gateway&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem create_route_unknown_gateway&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem create_route_unknown_gateway&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_route.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;create_route_unknown_gateway&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/route/&apos;, &apos;json&apos;: {&apos;gateway_id&apos;: 912348104, &apos;prefix&apos;: &apos;9193&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_route&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2d8866a0&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/route/&apos;, &apos;json&apos;: {&apos;gateway_id&apos;: 912348104, &apos;prefix&apos;: &apos;9193&apos;}, &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;create_route&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd...teway_id&apos;: 912348104, &apos;prefix&apos;: &apos;9193&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2da0c278&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /route/...HTTPConnection object at 0x7f3d2d886358&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_route.tavern.yaml" file="test_route.tavern.yaml" line="0" name="get_route_not_exists" time="0.008"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d9f4320&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_15&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d9f40f0&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d9f42b0&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d9f4320&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d9f42b0&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_15&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/j...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d9f44a8&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_15&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_15&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_15&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_15&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 62\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d7d37b8&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d9f40f0&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d9f4320&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_15&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d9f40f0&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d9f42b0&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2d9f4320&gt;, _stacktrace = &lt;traceback object at 0x7f3d2d879f48&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2d7d3f98&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2d7d3a58&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_15&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2d7d3a58&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d7d37b8&gt;, start = 1578473956.2076824

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d7d37b8&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d9f40f0&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2d9f40b8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2dbeb6a8&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem get_route_not_exists&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ot_exists&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem get_route_not_exists&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ot_exists&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem get_route_not_exists&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ot_exists&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem get_route_not_exists&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d30df1668&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...ot_exists&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem get_route_not_exists&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem get_route_not_exists&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem get_route_not_exists&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_route.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;get_route_not_exists&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_ad...&apos;http://localhost:8000/route/1948102948/&apos;, &apos;method&apos;: &apos;GET&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 404}, &apos;name&apos;: &apos;get_gateway&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2d7d3a58&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gatewa... &apos;method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 201, &apos;save&apos;: {&apos;body&apos;: {&apos;gateway_id&apos;: &apos;id&apos;}}}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd...1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_15&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2d7d3f98&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d2d9f40b8&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_search.tavern.yaml" file="test_search.tavern.yaml" line="0" name="route_search" time="0.010"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1dac8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_10&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d8d0&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d438&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1dac8&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;, method = &apos;POST&apos;
url = &apos;/gateway/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d438&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_10&quot;}&apos;, &apos;headers&apos;: {&apos;Content-Type&apos;: &apos;application/j...ser-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d2e8&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_10&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_10&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_10&quot;}&apos;

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;, message_body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_10&quot;}&apos;

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;
data = b&apos;POST /gateway/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\nContent-Length: 62\r\nContent-Type: application/json\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d7a1fd0&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d8d0&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1dac8&gt;, method = &apos;POST&apos;, url = &apos;/gateway/&apos;
body = b&apos;{&quot;ip_addresses&quot;: [&quot;1.1.1.1&quot;, &quot;8.8.8.8&quot;], &quot;name&quot;: &quot;gateway_10&quot;}&apos;
headers = {&apos;Content-Type&apos;: &apos;application/json&apos;, &apos;Content-Length&apos;: &apos;62&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d8d0&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d438&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;POST&apos;, url = &apos;/gateway/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d31b1dac8&gt;, _stacktrace = &lt;traceback object at 0x7f3d2d938908&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2d7a1f98&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2dc2ad30&gt;, method = &apos;POST&apos;, url = &apos;http://localhost:8000/gateway/&apos;, params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True, cert = None
json = {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_10&apos;}

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2dc2ad30&gt;, request = &lt;PreparedRequest [POST]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d7a1fd0&gt;, start = 1578473956.4526734

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d7a1fd0&gt;, request = &lt;PreparedRequest [POST]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d31b1d8d0&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gateway/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d31b1d0f0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2dbeb2f0&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem route_search&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...te_search&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem route_search&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...te_search&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem route_search&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...te_search&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem route_search&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d31b1d630&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...te_search&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem route_search&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem route_search&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem route_search&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_search.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;route_search&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;...ocalhost:8000/search/route/18039112217/&apos;, &apos;method&apos;: &apos;GET&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 404}, &apos;name&apos;: &apos;search_route&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2dc2ad30&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/gateway/&apos;, &apos;json&apos;: {&apos;ip_addresses&apos;: [&apos;1.1.1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gatewa...method&apos;: &apos;POST&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 201, &apos;save&apos;: {&apos;body&apos;: {&apos;gateway_id_1&apos;: &apos;id&apos;}}}, &apos;name&apos;: &apos;create_gateway&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd...1.1&apos;, &apos;8.8.8.8&apos;], &apos;name&apos;: &apos;gateway_10&apos;}, &apos;method&apos;: &apos;POST&apos;, &apos;verify&apos;: True, &apos;stream&apos;: False, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2d7a1f98&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /gatewa...HTTPConnection object at 0x7f3d31b1d0f0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase><testcase classname="test_search.tavern.yaml" file="test_search.tavern.yaml" line="0" name="route_search_invalid_number" time="0.007"><failure message="tavern.util.exceptions.RestRequestException">self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
&gt;               (self._dns_host, self.port), self.timeout, **extra_kw
            )

venv/lib/python3.5/site-packages/urllib3/connection.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except socket.error as e:
                err = e
                if sock is not None:
                    sock.close()
                    sock = None
    
        if err is not None:
&gt;           raise err

venv/lib/python3.5/site-packages/urllib3/util/connection.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

address = (&apos;localhost&apos;, 8000), timeout = None, source_address = None, socket_options = [(6, 1, 1)]

    def create_connection(
        address,
        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
        source_address=None,
        socket_options=None,
    ):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        if host.startswith(&quot;[&quot;):
            host = host.strip(&quot;[]&quot;)
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/util/connection.py:74: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2dabcd68&gt;, method = &apos;GET&apos;, url = &apos;/search/route/abcdef/&apos;, body = None
headers = {&apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d8e64e0&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabc048&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
&gt;               chunked=chunked,
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2dabcd68&gt;, conn = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;, method = &apos;GET&apos;
url = &apos;/search/route/abcdef/&apos;, timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabc048&gt;, chunked = False
httplib_request_kw = {&apos;body&apos;: None, &apos;headers&apos;: {&apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept&apos;: &apos;*/*&apos;}}
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabc208&gt;

    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        &quot;&quot;&quot;
        Perform a request on a given urllib connection object taken from our
        pool.
    
        :param conn:
            a connection from one of our connection pools
    
        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        &quot;&quot;&quot;
        self.num_requests += 1
    
        timeout_obj = self._get_timeout(timeout)
        timeout_obj.start_connect()
        conn.timeout = timeout_obj.connect_timeout
    
        # Trigger any extra validation we need to do.
        try:
            self._validate_conn(conn)
        except (SocketTimeout, BaseSSLError) as e:
            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)
            raise
    
        # conn.request() calls httplib.*.request, not the method in
        # urllib3.request. It also calls makefile (recv) on the socket.
        if chunked:
            conn.request_chunked(method, url, **httplib_request_kw)
        else:
&gt;           conn.request(method, url, **httplib_request_kw)

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;, method = &apos;GET&apos;, url = &apos;/search/route/abcdef/&apos;, body = None
headers = {&apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def request(self, method, url, body=None, headers={}):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers)

/usr/lib/python3.5/http/client.py:1122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;, method = &apos;GET&apos;, url = &apos;/search/route/abcdef/&apos;, body = None
headers = {&apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept&apos;: &apos;*/*&apos;}

    def _send_request(self, method, url, body, headers):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = dict.fromkeys([k.lower() for k in headers])
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        if &apos;content-length&apos; not in header_names:
            self._set_content_length(body, method)
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body)

/usr/lib/python3.5/http/client.py:1167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;, message_body = None

    def endheaders(self, message_body=None):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
        This method sends the request to the server.  The optional message_body
        argument can be used to pass a message body associated with the
        request.  The message body will be sent in the same packet as the
        message headers if it is a string, otherwise it is sent as a separate
        packet.
        &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body)

/usr/lib/python3.5/http/client.py:1118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;, message_body = None

    def _send_output(self, message_body=None):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
        Appends an extra \\r\\n to the buffer.
        A message_body may be specified, to be appended to the request.
        &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
    
&gt;       self.send(msg)

/usr/lib/python3.5/http/client.py:944: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;
data = b&apos;GET /search/route/abcdef/ HTTP/1.1\r\nHost: localhost:8000\r\nAccept-Encoding: gzip, deflate\r\nConnection: keep-alive\r\nUser-Agent: python-requests/2.22.0\r\nAccept: */*\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
        ``data`` can be a string object, a bytes object, an array object, a
        file-like object that supports a .read() method, or an iterable object.
        &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

/usr/lib/python3.5/http/client.py:887: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;

    def connect(self):
&gt;       conn = self._new_conn()

venv/lib/python3.5/site-packages/urllib3/connection.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;

    def _new_conn(self):
        &quot;&quot;&quot; Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        &quot;&quot;&quot;
        extra_kw = {}
        if self.source_address:
            extra_kw[&quot;source_address&quot;] = self.source_address
    
        if self.socket_options:
            extra_kw[&quot;socket_options&quot;] = self.socket_options
    
        try:
            conn = connection.create_connection(
                (self._dns_host, self.port), self.timeout, **extra_kw
            )
    
        except SocketTimeout:
            raise ConnectTimeoutError(
                self,
                &quot;Connection to %s timed out. (connect timeout=%s)&quot;
                % (self.host, self.timeout),
            )
    
        except SocketError as e:
            raise NewConnectionError(
&gt;               self, &quot;Failed to establish a new connection: %s&quot; % e
            )
E           urllib3.exceptions.NewConnectionError: &lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;: Failed to establish a new connection: [Errno 111] Connection refused

venv/lib/python3.5/site-packages/urllib3/connection.py:169: NewConnectionError

During handling of the above exception, another exception occurred:

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d8e6278&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d8e64e0&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
&gt;                   timeout=timeout
                )

venv/lib/python3.5/site-packages/requests/adapters.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2dabcd68&gt;, method = &apos;GET&apos;, url = &apos;/search/route/abcdef/&apos;, body = None
headers = {&apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;User-Agent&apos;: &apos;python-requests/2.22.0&apos;, &apos;Accept&apos;: &apos;*/*&apos;}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None), redirect = False, assert_same_host = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d8e64e0&gt;, pool_timeout = None, release_conn = False, chunked = False, body_pos = None
response_kw = {&apos;decode_content&apos;: False, &apos;preload_content&apos;: False}, conn = None, release_this_conn = True, err = None, clean_exit = False
timeout_obj = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2dabc048&gt;, is_new_proxy_conn = False

    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        &quot;&quot;&quot;
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you&apos;ll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it&apos;s appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            Pass ``None`` to retry until you receive a response. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you&apos;re not preloading
            the response&apos;s content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get(&apos;preload_content&apos;, True)``.
    
        :param chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won&apos;t need to be set because urllib3 will
            auto-populate the value when needed.
    
        :param \\**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        &quot;&quot;&quot;
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = response_kw.get(&quot;preload_content&quot;, True)
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we&apos;re connecting to is properly encoded
        if url.startswith(&quot;/&quot;):
            url = six.ensure_str(_encode_target(url))
        else:
            url = six.ensure_str(parse_url(url).url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;
        release_this_conn = release_conn
    
        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else&apos;s copy.
        if self.scheme == &quot;http&quot;:
            headers = headers.copy()
            headers.update(self.proxy_headers)
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout
    
            is_new_proxy_conn = self.proxy is not None and not getattr(
                conn, &quot;sock&quot;, None
            )
            if is_new_proxy_conn:
                self._prepare_proxy(conn)
    
            # Make the request on the httplib connection object.
            httplib_response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
            )
    
            # If we&apos;re going to release the connection in ``finally:``, then
            # the response doesn&apos;t need to know about the connection. Otherwise
            # it will also try to release it and we&apos;ll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Pass method to Response for length checking
            response_kw[&quot;request_method&quot;] = method
    
            # Import httplib&apos;s response into our own wrapper object
            response = self.ResponseCls.from_httplib(
                httplib_response,
                pool=self,
                connection=response_conn,
                retries=retries,
                **response_kw
            )
    
            # Everything went great!
            clean_exit = True
    
        except queue.Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, &quot;No pool connections are available.&quot;)
    
        except (
            TimeoutError,
            HTTPException,
            SocketError,
            ProtocolError,
            BaseSSLError,
            SSLError,
            CertificateError,
        ) as e:
            # Discard the connection for these exceptions. It will be
            # replaced during the next _get_conn() call.
            clean_exit = False
            if isinstance(e, (BaseSSLError, CertificateError)):
                e = SSLError(e)
            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
                e = ProxyError(&quot;Cannot connect to proxy.&quot;, e)
            elif isinstance(e, (SocketError, HTTPException)):
                e = ProtocolError(&quot;Connection aborted.&quot;, e)
    
            retries = retries.increment(
&gt;               method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]
            )

venv/lib/python3.5/site-packages/urllib3/connectionpool.py:720: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Retry(total=0, connect=None, read=False, redirect=None, status=None), method = &apos;GET&apos;, url = &apos;/search/route/abcdef/&apos;, response = None
error = NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,)
_pool = &lt;urllib3.connectionpool.HTTPConnectionPool object at 0x7f3d2dabcd68&gt;, _stacktrace = &lt;traceback object at 0x7f3d2d888cc8&gt;

    def increment(
        self,
        method=None,
        url=None,
        response=None,
        error=None,
        _pool=None,
        _stacktrace=None,
    ):
        &quot;&quot;&quot; Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.HTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        &quot;&quot;&quot;
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise six.reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        cause = &quot;unknown&quot;
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise six.reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or not self._is_method_retryable(method):
                raise six.reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = &quot;too many redirects&quot;
            redirect_location = response.get_redirect_location()
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and a the given method is in the whitelist
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            history=history,
        )
    
        if new_retry.is_exhausted():
&gt;           raise MaxRetryError(_pool, url, error or ResponseError(cause))
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /search/route/abcdef/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/urllib3/util/retry.py:436: MaxRetryError

During handling of the above exception, another exception occurred:

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2d8e6358&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
&gt;           return self._prepared()

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def prepared_request():
        # If there are open files, create a context manager around each so
        # they will be closed at the end of the request.
        with ExitStack() as stack:
            stack.enter_context(_set_cookies_for_request(session, request_args))
            self._request_args.update(_get_file_arguments(request_args, stack))
&gt;           return session.request(**self._request_args)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2d8e6048&gt;, method = &apos;GET&apos;, url = &apos;http://localhost:8000/search/route/abcdef/&apos;, params = None, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None, allow_redirects = False, proxies = {}, hooks = None, stream = False, verify = True
cert = None, json = None

    def request(self, method, url,
            params=None, data=None, headers=None, cookies=None, files=None,
            auth=None, timeout=None, allow_redirects=True, proxies=None,
            hooks=None, stream=None, verify=None, cert=None, json=None):
        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
        Returns :class:`Response &lt;Response&gt;` object.
    
        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
            object to send in the body of the :class:`Request`.
        :param json: (optional) json to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of ``&apos;filename&apos;: file-like-objects``
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple
        :param allow_redirects: (optional) Set to True by default.
        :type allow_redirects: bool
        :param proxies: (optional) Dictionary mapping protocol or protocol and
            hostname to the URL of the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) Either a boolean, in which case it controls whether we verify
            the server&apos;s TLS certificate, or a string, in which case it must be a path
            to a CA bundle to use. Defaults to ``True``.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, (&apos;cert&apos;, &apos;key&apos;) pair.
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Create the Request.
        req = Request(
            method=method.upper(),
            url=url,
            headers=headers,
            files=files,
            data=data or {},
            json=json,
            params=params or {},
            auth=auth,
            cookies=cookies,
            hooks=hooks,
        )
        prep = self.prepare_request(req)
    
        proxies = proxies or {}
    
        settings = self.merge_environment_settings(
            prep.url, proxies, stream, verify, cert
        )
    
        # Send the request.
        send_kwargs = {
            &apos;timeout&apos;: timeout,
            &apos;allow_redirects&apos;: allow_redirects,
        }
        send_kwargs.update(settings)
&gt;       resp = self.send(prep, **send_kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:533: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.sessions.Session object at 0x7f3d2d8e6048&gt;, request = &lt;PreparedRequest [GET]&gt;
kwargs = {&apos;cert&apos;: None, &apos;proxies&apos;: OrderedDict(), &apos;stream&apos;: False, &apos;timeout&apos;: None, ...}, allow_redirects = False, stream = False, hooks = {&apos;response&apos;: []}
adapter = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d8e6278&gt;, start = 1578473956.6785917

    def send(self, request, **kwargs):
        &quot;&quot;&quot;Send a given PreparedRequest.
    
        :rtype: requests.Response
        &quot;&quot;&quot;
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault(&apos;stream&apos;, self.stream)
        kwargs.setdefault(&apos;verify&apos;, self.verify)
        kwargs.setdefault(&apos;cert&apos;, self.cert)
        kwargs.setdefault(&apos;proxies&apos;, self.proxies)
    
        # It&apos;s possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if isinstance(request, Request):
            raise ValueError(&apos;You can only send PreparedRequests.&apos;)
    
        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop(&apos;allow_redirects&apos;, True)
        stream = kwargs.get(&apos;stream&apos;)
        hooks = request.hooks
    
        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)
    
        # Start time (approximately) of the request
        start = preferred_clock()
    
        # Send the request
&gt;       r = adapter.send(request, **kwargs)

venv/lib/python3.5/site-packages/requests/sessions.py:646: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;requests.adapters.HTTPAdapter object at 0x7f3d2d8e6278&gt;, request = &lt;PreparedRequest [GET]&gt;, stream = False
timeout = &lt;urllib3.util.timeout.Timeout object at 0x7f3d2d8e64e0&gt;, verify = True, cert = None, proxies = OrderedDict()

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) &lt;timeouts&gt;` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server&apos;s TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        &quot;&quot;&quot;
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)
    
        chunked = not (request.body is None or &apos;Content-Length&apos; in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError as e:
                # this may raise a string formatting error.
                err = (&quot;Invalid timeout {}. Pass a (connect, read) &quot;
                       &quot;timeout tuple, or a single float to set &quot;
                       &quot;both timeouts to the same value&quot;.format(timeout))
                raise ValueError(err)
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )
    
            # Send the request.
            else:
                if hasattr(conn, &apos;proxy_pool&apos;):
                    conn = conn.proxy_pool
    
                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)
    
                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)
    
                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)
    
                    low_conn.endheaders()
    
                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode(&apos;utf-8&apos;))
                        low_conn.send(b&apos;\r\n&apos;)
                        low_conn.send(i)
                        low_conn.send(b&apos;\r\n&apos;)
                    low_conn.send(b&apos;0\r\n\r\n&apos;)
    
                    # Receive the response from the server
                    try:
                        # For Python 2.7, use buffering of HTTP responses
                        r = low_conn.getresponse(buffering=True)
                    except TypeError:
                        # For compatibility with Python 3.3+
                        r = low_conn.getresponse()
    
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
    
        except (ProtocolError, socket.error) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
&gt;           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /search/route/abcdef/ (Caused by NewConnectionError(&apos;&lt;urllib3.connection.HTTPConnection object at 0x7f3d2dabc0f0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))

venv/lib/python3.5/site-packages/requests/adapters.py:516: ConnectionError

The above exception was the direct cause of the following exception:

cls = &lt;class &apos;_pytest.runner.CallInfo&apos;&gt;, func = &lt;function call_runtest_hook.&lt;locals&gt;.&lt;lambda&gt; at 0x7f3d2d9cfd08&gt;, when = &apos;call&apos;
reraise = (&lt;class &apos;_pytest.outcomes.Exit&apos;&gt;, &lt;class &apos;KeyboardInterrupt&apos;&gt;)

    @classmethod
    def from_call(cls, func, when, reraise=None):
        #: context of invocation: one of &quot;setup&quot;, &quot;call&quot;,
        #: &quot;teardown&quot;, &quot;memocollect&quot;
        start = time()
        excinfo = None
        try:
&gt;           result = func()

venv/lib/python3.5/site-packages/_pytest/runner.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;       lambda: ihook(item=item, **kwds), when=when, reraise=reraise
    )

venv/lib/python3.5/site-packages/_pytest/runner.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;, args = (), kwargs = {&apos;item&apos;: &lt;YamlItem route_search_invalid_number&gt;}, notincall = set()

    def __call__(self, *args, **kwargs):
        if args:
            raise TypeError(&quot;hook calling supports only keyword arguments&quot;)
        assert not self.is_historic()
        if self.spec and self.spec.argnames:
            notincall = (
                set(self.spec.argnames) - set([&quot;__multicall__&quot;]) - set(kwargs.keys())
            )
            if notincall:
                warnings.warn(
                    &quot;Argument(s) {} which are declared in the hookspec &quot;
                    &quot;can not be found in this hook call&quot;.format(tuple(notincall)),
                    stacklevel=2,
                )
&gt;       return self._hookexec(self, self.get_hookimpls(), kwargs)

venv/lib/python3.5/site-packages/pluggy/hooks.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.config.PytestPluginManager object at 0x7f3d34c40fd0&gt;, hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...id_number&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem route_search_invalid_number&gt;}

    def _hookexec(self, hook, methods, kwargs):
        # called from all hookcaller instances.
        # enable_tracing will set its own wrapping function at self._inner_hookexec
&gt;       return self._inner_hookexec(hook, methods, kwargs)

venv/lib/python3.5/site-packages/pluggy/manager.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook = &lt;_HookCaller &apos;pytest_runtest_call&apos;&gt;
methods = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...id_number&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
kwargs = {&apos;item&apos;: &lt;YamlItem route_search_invalid_number&gt;}

    self._inner_hookexec = lambda hook, methods, kwargs: hook.multicall(
        methods,
        kwargs,
&gt;       firstresult=hook.spec.opts.get(&quot;firstresult&quot;) if hook.spec else False,
    )

venv/lib/python3.5/site-packages/pluggy/manager.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...id_number&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem route_search_invalid_number&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
                        res = hook_impl.function(*args)
                        if res is not None:
                            results.append(res)
                            if firstresult:  # halt further impl calls
                                break
            except BaseException:
                excinfo = sys.exc_info()
        finally:
            if firstresult:  # first result hooks return a single value
                outcome = _Result(results[0] if results else None, excinfo)
            else:
                outcome = _Result(results, excinfo)
    
            # run all wrapper post-yield blocks
            for gen in reversed(teardowns):
                try:
                    gen.send(outcome)
                    _raise_wrapfail(gen, &quot;has second yield&quot;)
                except StopIteration:
                    pass
    
&gt;           return outcome.get_result()

venv/lib/python3.5/site-packages/pluggy/callers.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;pluggy.callers._Result object at 0x7f3d2dc21cc0&gt;

    def get_result(self):
        &quot;&quot;&quot;Get the result(s) for this hook call.
    
        If the hook was marked as a ``firstresult`` only a single value
        will be returned otherwise a list of results.
        &quot;&quot;&quot;
        __tracebackhide__ = True
        if self._excinfo is None:
            return self._result
        else:
            ex = self._excinfo
            if _py3:
&gt;               raise ex[1].with_traceback(ex[2])

venv/lib/python3.5/site-packages/pluggy/callers.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

hook_impls = [&lt;HookImpl plugin_name=&apos;runner&apos;, plugin=&lt;module &apos;_pytest.runner&apos; from &apos;/home/shashank/projects/hackerrank/python2/.que...id_number&gt;&gt;&gt;, &lt;HookImpl plugin_name=&apos;logging-plugin&apos;, plugin=&lt;_pytest.logging.LoggingPlugin object at 0x7f3d30ec9b70&gt;&gt;]
caller_kwargs = {&apos;item&apos;: &lt;YamlItem route_search_invalid_number&gt;}, firstresult = False

    def _multicall(hook_impls, caller_kwargs, firstresult=False):
        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the
        result(s).
    
        ``caller_kwargs`` comes from _HookCaller.__call__().
        &quot;&quot;&quot;
        __tracebackhide__ = True
        results = []
        excinfo = None
        try:  # run impl and wrapper setup functions in a loop
            teardowns = []
            try:
                for hook_impl in reversed(hook_impls):
                    try:
                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]
                    except KeyError:
                        for argname in hook_impl.argnames:
                            if argname not in caller_kwargs:
                                raise HookCallError(
                                    &quot;hook call must provide argument %r&quot; % (argname,)
                                )
    
                    if hook_impl.hookwrapper:
                        try:
                            gen = hook_impl.function(*args)
                            next(gen)  # first yield
                            teardowns.append(gen)
                        except StopIteration:
                            _raise_wrapfail(gen, &quot;did not yield&quot;)
                    else:
&gt;                       res = hook_impl.function(*args)

venv/lib/python3.5/site-packages/pluggy/callers.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;YamlItem route_search_invalid_number&gt;

    def pytest_runtest_call(item):
        _update_current_test_var(item, &quot;call&quot;)
        sys.last_type, sys.last_value, sys.last_traceback = (None, None, None)
        try:
&gt;           item.runtest()

venv/lib/python3.5/site-packages/_pytest/runner.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;YamlItem route_search_invalid_number&gt;

    def runtest(self):
        self.global_cfg = load_global_cfg(self.config)
    
        self.global_cfg.setdefault(&quot;variables&quot;, {})
    
        load_plugins(self.global_cfg)
    
        self.global_cfg[&quot;tavern_internal&quot;] = {&quot;pytest_hook_caller&quot;: self.config.hook}
    
        # INTERNAL
        # NOTE - now that we can &apos;mark&apos; tests, we could use pytest.mark.xfail
        # instead. This doesn&apos;t differentiate between an error in verification
        # and an error when running the test though.
        xfail = self.spec.get(&quot;_xfail&quot;, False)
    
        try:
            fixture_values = self._load_fixture_values()
            self.global_cfg[&quot;variables&quot;].update(fixture_values)
    
            call_hook(
                self.global_cfg,
                &quot;pytest_tavern_beta_before_every_test_run&quot;,
                test_dict=self.spec,
                variables=self.global_cfg[&quot;variables&quot;],
            )
    
            verify_tests(self.spec)
    
&gt;           run_test(self.path, self.spec, self.global_cfg)

venv/lib/python3.5/site-packages/tavern/testutils/pytesthook/item.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

in_file = local(&apos;/home/shashank/projects/hackerrank/python2/.questiontest/test_search.tavern.yaml&apos;)
test_spec = {&apos;test_name&apos;: &apos;route_search_invalid_number&apos;, &apos;stages&apos;: [{&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/search/route/abcdef/&apos;, &apos;method&apos;: &apos;GET&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;search_route&apos;}]}
global_cfg = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_test(in_file, test_spec, global_cfg):
        &quot;&quot;&quot;Run a single tavern test
    
        Note that each tavern test can consist of multiple requests (log in,
        create, update, delete, etc).
    
        The global configuration is copied and used as an initial configuration for
        this test. Any values which are saved from any tests are saved into this
        test block and can be used for formatting in later stages in the test.
    
        Args:
            in_file (str): filename containing this test
            test_spec (dict): The specification for this test
            global_cfg (dict): Any global configuration for this test
    
        No Longer Raises:
            TavernException: If any of the tests failed
        &quot;&quot;&quot;
    
        # pylint: disable=too-many-locals
    
        # Initialise test config for this test with the global configuration before
        # starting
        test_block_config = dict(global_cfg)
    
        if &quot;variables&quot; not in test_block_config:
            test_block_config[&quot;variables&quot;] = {}
    
        tavern_box = Box({&quot;env_vars&quot;: dict(os.environ)})
    
        if not test_spec:
            logger.warning(&quot;Empty test block in %s&quot;, in_file)
            return
    
        # Get included stages and resolve any into the test spec dictionary
        available_stages = test_block_config.get(&quot;stages&quot;, [])
        included_stages = _get_included_stages(
            tavern_box, test_block_config, test_spec, available_stages
        )
        all_stages = {s[&quot;id&quot;]: s for s in available_stages + included_stages}
        test_spec[&quot;stages&quot;] = _resolve_test_stages(test_spec, all_stages)
    
        test_block_config[&quot;variables&quot;][&quot;tavern&quot;] = tavern_box
    
        test_block_name = test_spec[&quot;test_name&quot;]
    
        # Strict on body by default
        default_strictness = test_block_config[&quot;strict&quot;]
    
        logger.info(&quot;Running test : %s&quot;, test_block_name)
    
        with ExitStack() as stack:
            sessions = get_extra_sessions(test_spec, test_block_config)
    
            for name, session in sessions.items():
                logger.debug(&quot;Entering context for %s&quot;, name)
                stack.enter_context(session)
    
            def getonly(stage):
                o = stage.get(&quot;only&quot;)
                if o is None:
                    return False
                elif isinstance(o, bool):
                    return o
                else:
                    return strtobool(o)
    
            has_only = any(getonly(stage) for stage in test_spec[&quot;stages&quot;])
    
            # Run tests in a path in order
            for stage in test_spec[&quot;stages&quot;]:
                if stage.get(&quot;skip&quot;):
                    continue
                elif has_only and not getonly(stage):
                    continue
    
                test_block_config[&quot;strict&quot;] = default_strictness
    
                # Can be overridden per stage
                # NOTE
                # this is hardcoded to check for the &apos;response&apos; block. In the far
                # future there might not be a response block, but at the moment it
                # is the hardcoded value for any HTTP request.
                if stage.get(&quot;response&quot;, {}):
                    if stage.get(&quot;response&quot;).get(&quot;strict&quot;, None) is not None:
                        stage_strictness = stage.get(&quot;response&quot;).get(&quot;strict&quot;, None)
                    elif test_spec.get(&quot;strict&quot;, None) is not None:
                        stage_strictness = test_spec.get(&quot;strict&quot;, None)
                    else:
                        stage_strictness = default_strictness
    
                    logger.debug(
                        &quot;Strict key checking for this stage is &apos;%s&apos;&quot;, stage_strictness
                    )
    
                    test_block_config[&quot;strict&quot;] = stage_strictness
                elif default_strictness:
                    logger.debug(
                        &quot;Default strictness &apos;%s&apos; ignored for this stage&quot;, default_strictness
                    )
    
                # Wrap run_stage with retry helper
                run_stage_with_retries = retry(stage, test_block_config)(run_stage)
    
                try:
&gt;                   run_stage_with_retries(sessions, stage, tavern_box, test_block_config)

venv/lib/python3.5/site-packages/tavern/core.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sessions = {&apos;requests&apos;: &lt;requests.sessions.Session object at 0x7f3d2d8e6048&gt;}
stage = {&apos;request&apos;: {&apos;url&apos;: &apos;http://localhost:8000/search/route/abcdef/&apos;, &apos;method&apos;: &apos;GET&apos;}, &apos;response&apos;: {&apos;status_code&apos;: 400}, &apos;name&apos;: &apos;search_route&apos;}
tavern_box = &lt;Box: {&apos;env_vars&apos;: {&apos;PWD&apos;: &apos;/home/shashank/projects/hackerrank/python2/.questiontest&apos;, &apos;XDG_CONFIG_DIRS&apos;: &apos;/etc/xdg/xd...p://localhost:8000/search/route/abcdef/&apos;, &apos;method&apos;: &apos;GET&apos;, &apos;stream&apos;: False, &apos;verify&apos;: True, &apos;allow_redirects&apos;: False}}&gt;
test_block_config = {&apos;backends&apos;: {&apos;http&apos;: &apos;requests&apos;, &apos;mqtt&apos;: &apos;paho-mqtt&apos;}, &apos;follow_redirects&apos;: False, &apos;strict&apos;: [], &apos;tavern_internal&apos;: {&apos;pytest_hook_caller&apos;: &lt;pluggy.hooks._HookRelay object at 0x7f3d34c4ada0&gt;}, ...}

    def run_stage(sessions, stage, tavern_box, test_block_config):
        &quot;&quot;&quot;Run one stage from the test
    
        Args:
            sessions (dict): Dictionary of relevant &apos;session&apos; objects used for this test
            stage (dict): specification of stage to be run
            tavern_box (box.Box): Box object containing format variables to be used
                in test
            test_block_config (dict): available variables for test
        &quot;&quot;&quot;
        name = stage[&quot;name&quot;]
    
        r = get_request_type(stage, test_block_config, sessions)
    
        tavern_box.update(request_vars=r.request_vars)
    
        expected = get_expected(stage, test_block_config, sessions)
    
        delay(stage, &quot;before&quot;, test_block_config[&quot;variables&quot;])
    
        logger.info(&quot;Running stage : %s&quot;, name)
&gt;       response = r.run()

venv/lib/python3.5/site-packages/tavern/core.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tavern._plugins.rest.request.RestRequest object at 0x7f3d2d8e6358&gt;

    def run(self):
        &quot;&quot;&quot; Runs the prepared request and times it
    
        Todo:
            time it
    
        Returns:
            requests.Response: response object
        &quot;&quot;&quot;
    
        try:
            return self._prepared()
        except requests.exceptions.RequestException as e:
            logger.exception(&quot;Error running prepared request&quot;)
&gt;           raise_from(exceptions.RestRequestException, e)

venv/lib/python3.5/site-packages/tavern/_plugins/rest/request.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = &lt;class &apos;tavern.util.exceptions.RestRequestException&apos;&gt;
cause = ConnectionError(MaxRetryError(&quot;HTTPConnectionPool(host=&apos;localhost&apos;, port=8000): Max retries exceeded with url: /search...HTTPConnection object at 0x7f3d2dabc0f0&gt;: Failed to establish a new connection: [Errno 111] Connection refused&apos;,))&quot;,),)

    def raise_from(exc, cause):
        &quot;&quot;&quot;
        Equivalent to:
    
            raise EXCEPTION from CAUSE
    
        on Python 3. (See PEP 3134).
        &quot;&quot;&quot;
        myglobals, mylocals = _get_caller_globals_and_locals()
    
        # We pass the exception and cause along with other globals
        # when we exec():
        myglobals = myglobals.copy()
        myglobals[&apos;__python_future_raise_from_exc&apos;] = exc
        myglobals[&apos;__python_future_raise_from_cause&apos;] = cause
        execstr = &quot;raise __python_future_raise_from_exc from __python_future_raise_from_cause&quot;
&gt;       exec(execstr, myglobals, mylocals)

venv/lib/python3.5/site-packages/future/utils/__init__.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   tavern.util.exceptions.RestRequestException

&lt;string&gt;:1: RestRequestException</failure></testcase></testsuite>